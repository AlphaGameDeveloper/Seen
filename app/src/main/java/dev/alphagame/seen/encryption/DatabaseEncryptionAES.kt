// Seen - Mental Health Application
//     Copyright (C) 2025  Damien Boisvert
//                   2025  Alexander Cameron
//
//     Seen is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Seen is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Seen.  If not, see <https://www.gnu.org/licenses/>.

package dev.alphagame.seen.encryption

import android.content.Context
import android.util.Log
import dev.alphagame.seen.security.KeyManager
import java.io.File
import javax.crypto.Cipher
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec

/**
 * Utility class for AES encryption lol
 * tl;dr AES-256 in CBC mode with PKCS5Padding for security. (yeah im in over my head)
 */
class DatabaseEncryptionAES {
    companion object {
        private const val TAG      = "AESEncryption"
        private const val AES_MODE = "AES/GCM/NoPadding"
        private const val GCM_TAG_LENGTH = 128 // 128-bit authentication tag
        private const val IV_SIZE  = 12 // GCM standard IV size is 12 bytes

        const val ENCRYPTED_DB_NAME = "seen_database_encrypted.db"
        const val TEMP_DB_NAME      = "seen_database_temp.db"

        fun bps2String(bps: Number): String {
            // for debugging lol
            // <insert "this is your brain on code optimizations" meme here>
            return "${"%.3f".format(bps.toDouble() / 1024)} KiB/s; ${"%.3f".format(bps.toDouble() / 1048576)} MiB/s"
        }

        private fun getSecretKey(): SecretKey {
            return KeyManager.getOrCreateAesKey()
        }

        fun encryptFile(inputFile: File, outputFile: File) {
            try {
                val inputBytes = inputFile.readBytes()
                val cipher = Cipher.getInstance(AES_MODE)

                // Android KeyStore will generate the IV automatically
                cipher.init(Cipher.ENCRYPT_MODE, getSecretKey())

                val encryptedBytes = cipher.doFinal(inputBytes)
                
                // Get the IV that was generated by the cipher
                val iv = cipher.iv

                // prepend iv to ciphertext for decryption
                outputFile.outputStream().use {
                    it.write(iv)
                    it.write(encryptedBytes)
                }

                Log.d(TAG, "AES Encryption complete. File size is ${outputFile.length()/1024} KiB")
            } catch (e: Exception) {
                throw Exception("Failed to encrypt database: ${e.message}", e)
            }
        }

        fun decryptFile(inputFile: File, outputFile: File) {
            try {
                if (!inputFile.exists()) {
                    Log.e(TAG, "wtf can't read nonexistent input file")
                    outputFile.createNewFile()
                    return
                }

                val allBytes = inputFile.readBytes()
                // file is in fmt:
                // - first (IV_SIZE) bytes is IV
                // - rest is encrypted data (includes GCM auth tag)
                val iv = allBytes.copyOfRange(0, IV_SIZE)
                val encryptedBytes = allBytes.copyOfRange(IV_SIZE, allBytes.size)

                val cipher = Cipher.getInstance(AES_MODE)
                val gcmSpec = GCMParameterSpec(GCM_TAG_LENGTH, iv)
                cipher.init(Cipher.DECRYPT_MODE, getSecretKey(), gcmSpec)

                val decryptedBytes = cipher.doFinal(encryptedBytes)
                outputFile.writeBytes(decryptedBytes)

            } catch (e: Exception) {
                throw Exception("Failed to decrypt DB file: ${e.message}", e)
            }
        }

        fun getEncryptedDbPath(context: Context): String {
            return File(context.filesDir, ENCRYPTED_DB_NAME).absolutePath
        }

        fun getTempDbPath(context: Context): String {
            return File(context.filesDir, TEMP_DB_NAME).absolutePath
        }

        fun cleanupTempDb(context: Context) {
            val tempFile = File(getTempDbPath(context))
            if (tempFile.exists()) {
                Log.i(TAG, "Deleting the decrypted DB file at ${tempFile.absolutePath}")
                tempFile.delete()
            }
        }

        fun encryptedDbExists(context: Context): Boolean {
            return File(getEncryptedDbPath(context)).exists()
        }
    }
}
